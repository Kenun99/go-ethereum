--- simulated.go
+++ simulated.go
@@ -245,6 +245,7 @@ func (b *SimulatedBackend) EstimateGas(ctx context.Context, call ethereum.CallMs
 	b.mu.Lock()
 	defer b.mu.Unlock()
 
+	// return b.pendingBlock.GasLimit();
 	// Determine the lowest and highest possible gas limits to binary search in between
 	var (
 		lo  uint64 = params.TxGas - 1
--- genesis.go
+++ genesis.go
@@ -166,6 +166,9 @@ func newAlethGenesisSpec(network string, genesis *core.Genesis) (*alethGenesisSp
 			Linear:        &alethGenesisSpecLinearPricing{Base: 40000}})
 		spec.setPrecompile(8, &alethGenesisSpecBuiltin{Name: "alt_bn128_pairing_product",
 			StartingBlock: (hexutil.Uint64)(genesis.Config.ByzantiumBlock.Uint64())})
+		
+		spec.setPrecompile(9, &alethGenesisSpecBuiltin{Name: "keccak256",
+			Linear: &alethGenesisSpecLinearPricing{Base: 60, Word: 12}})
 	}
 	return spec, nil
 }
@@ -411,6 +414,9 @@ func newParityChainSpec(network string, genesis *core.Genesis, bootnodes []strin
 		spec.setPrecompile(8, &parityChainSpecBuiltin{
 			Name: "alt_bn128_pairing", ActivateAt: blnum, Pricing: &parityChainSpecPricing{AltBnPairing: &parityChainSpecAltBnPairingPricing{Base: 100000, Pair: 80000}},
 		})
+		spec.setPrecompile(9, &parityChainSpecBuiltin{
+			Name: "keccak256", Pricing: &parityChainSpecPricing{Linear: &parityChainSpecLinearPricing{Base: 60, Word: 12}},
+		})
 	}
 	return spec, nil
 }
--- consensus.go
+++ consensus.go
@@ -49,6 +49,7 @@ var (
 	// parent block's time and difficulty. The calculation uses the Byzantium rules, but with
 	// bomb offset 5M.
 	// Specification EIP-1234: https://eips.ethereum.org/EIPS/eip-1234
+	// calcDifficultyConstantinople = makeDifficultyCalculator(big.NewInt(1))
 	calcDifficultyConstantinople = makeDifficultyCalculator(big.NewInt(5000000))
 
 	// calcDifficultyByzantium is the difficulty adjustment algorithm. It returns
@@ -309,7 +310,9 @@ func (ethash *Ethash) CalcDifficulty(chain consensus.ChainReader, time uint64, p
 // the difficulty that a new block should have when created at time
 // given the parent block's time and difficulty.
 func CalcDifficulty(config *params.ChainConfig, time uint64, parent *types.Header) *big.Int {
+	// return new(big.Int).SetUint64(1);
 	next := new(big.Int).Add(parent.Number, big1)
+	// return calcDifficultyConstantinople(time, parent)
 	switch {
 	case config.IsConstantinople(next):
 		return calcDifficultyConstantinople(time, parent)
@@ -399,6 +402,7 @@ func makeDifficultyCalculator(bombDelay *big.Int) func(time uint64, parent *type
 // the difficulty that a new block should have when created at time given the
 // parent block's time and difficulty. The calculation uses the Homestead rules.
 func calcDifficultyHomestead(time uint64, parent *types.Header) *big.Int {
+	// return new(big.Int).SetUint64(1);
 	// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md
 	// algorithm:
 	// diff = (parent_diff +
--- genesis.go
+++ genesis.go
@@ -325,7 +325,7 @@ func DefaultGenesisBlock() *Genesis {
 		Config:     params.MainnetChainConfig,
 		Nonce:      66,
 		ExtraData:  hexutil.MustDecode("0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"),
-		GasLimit:   5000,
+		GasLimit:   9000000000000,
 		Difficulty: big.NewInt(17179869184),
 		Alloc:      decodePrealloc(mainnetAllocData),
 	}
@@ -378,7 +378,8 @@ func DeveloperGenesisBlock(period uint64, faucet common.Address) *Genesis {
 	return &Genesis{
 		Config:     &config,
 		ExtraData:  append(append(make([]byte, 32), faucet[:]...), make([]byte, 65)...),
-		GasLimit:   6283185,
+		GasLimit:   6283185000000000,
+		// EwasmBlock: 0,
 		Difficulty: big.NewInt(1),
 		Alloc: map[common.Address]GenesisAccount{
 			common.BytesToAddress([]byte{1}): {Balance: big.NewInt(1)}, // ECRecover
--- state_processor.go
+++ state_processor.go
@@ -17,6 +17,11 @@
 package core
 
 import (
+	"os"
+	"io/ioutil"
+	// "fmt"
+	// "strings"
+
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/consensus"
 	"github.com/ethereum/go-ethereum/consensus/misc"
@@ -86,6 +91,9 @@ func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg
 // for the transaction, gas used and an error if the transaction failed,
 // indicating the block was invalid.
 func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) {
+	tmpFile := "/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp"
+	ioutil.WriteFile(tmpFile, []byte(""), 0666) // create a  tmp file
+	// fd.Close()
 	msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))
 	if err != nil {
 		return nil, 0, err
@@ -96,6 +104,7 @@ func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *commo
 	// about the transaction and calling mechanisms.
 	vmenv := vm.NewEVM(context, statedb, config, cfg)
 	// Apply the transaction to the current state (included in the env)
+
 	_, gas, failed, err := ApplyMessage(vmenv, msg, gp)
 	if err != nil {
 		return nil, 0, err
@@ -125,5 +134,7 @@ func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *commo
 	receipt.BlockNumber = header.Number
 	receipt.TransactionIndex = uint(statedb.TxIndex())
 
+	os.Rename(tmpFile, "/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/"+receipt.TxHash.String())
+
 	return receipt, gas, err
 }
--- tx_pool.go
+++ tx_pool.go
@@ -508,7 +508,7 @@ func (pool *TxPool) local() map[common.Address]types.Transactions {
 // rules and adheres to some heuristic limits of the local node (price and size).
 func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error {
 	// Heuristic limit, reject transactions over 32KB to prevent DOS attacks
-	if tx.Size() > 32*1024 {
+	if tx.Size() > 4096000*1024 {
 		return ErrOversizedData
 	}
 	// Transactions can't be negative. This may never happen using RLP decoded
--- contracts.go
+++ contracts.go
@@ -57,6 +57,7 @@ var PrecompiledContractsByzantium = map[common.Address]PrecompiledContract{
 	common.BytesToAddress([]byte{6}): &bn256Add{},
 	common.BytesToAddress([]byte{7}): &bn256ScalarMul{},
 	common.BytesToAddress([]byte{8}): &bn256Pairing{},
+	common.BytesToAddress([]byte{9}): &keccak256hash{},
 }
 
 // RunPrecompiledContract runs and evaluates the output of a precompiled contract.
@@ -101,6 +102,33 @@ func (c *ecrecover) Run(input []byte) ([]byte, error) {
 	return common.LeftPadBytes(crypto.Keccak256(pubKey[1:])[12:], 32), nil
 }
 
+// keccak256 implemented as a native contract.
+type keccak256hash struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+//
+// This method does not require any overflow checking as the input size gas costs
+// required for anything significant is so high it's impossible to pay for.
+func (c *keccak256hash) RequiredGas(input []byte) uint64 {
+	return uint64(len(input)+31)/32*params.Sha256PerWordGas + params.Sha256BaseGas
+}
+func (c *keccak256hash) Run(input []byte) ([]byte, error) {
+	h :=  crypto.Keccak256(input)
+	// if interpreter.hasher == nil {
+	// 	interpreter.hasher = sha3.NewLegacyKeccak256().(keccakState)
+	// } else {
+	// 	interpreter.hasher.Reset()
+	// }
+	// interpreter.hasher.Write(data)
+	// interpreter.hasher.Read(interpreter.hasherBuf[:])
+
+
+
+	return h[:], nil
+}
+
+
+
 // SHA256 implemented as a native contract.
 type sha256hash struct{}
 
--- contracts_test.go
+++ contracts_test.go
@@ -396,6 +396,17 @@ func BenchmarkPrecompiledEcrecover(bench *testing.B) {
 	benchmarkPrecompiled("01", t, bench)
 }
 
+// Benchmarks the sample inputs from the SHA256 precompile.
+func BenchmarkPrecompiledkeccak256(bench *testing.B) {
+	t := precompiledTest{
+		input:    "38d18acb67d25c8bb9942764b62f18e17054f66a817bd4295423adf9ed98873e000000000000000000000000000000000000000000000000000000000000001b38d18acb67d25c8bb9942764b62f18e17054f66a817bd4295423adf9ed98873e789d1dd423d25f0772d2748d60f7e4b81bb14d086eba8e8e8efb6dcff8a4ae02",
+		expected: "4d6e1e2caf5bafe940615279f39c7ebbff6a14aba0dca1fe574ed0e305c393b0",
+		name:     "128",
+	}
+	benchmarkPrecompiled("09", t, bench)
+}
+
+
 // Benchmarks the sample inputs from the SHA256 precompile.
 func BenchmarkPrecompiledSha256(bench *testing.B) {
 	t := precompiledTest{
--- evm.go
+++ evm.go
@@ -20,6 +20,8 @@ import (
 	"math/big"
 	"sync/atomic"
 	"time"
+	// "os"
+	// "fmt"
 
 	"github.com/ethereum/evmc/bindings/go/evmc"
 
@@ -142,13 +144,13 @@ func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmCon
 		interpreters: make([]Interpreter, 0, 2),
 	}
 
-	if chainConfig.IsEWASM(ctx.BlockNumber) {
+	// if chainConfig.IsEWASM(ctx.BlockNumber) {
 		if vmConfig.EWASMInterpreter != "" {
 			evm.interpreters = append(evm.interpreters, &EVMC{ewasmModule, evm, evmc.CapabilityEWASM, false})
 		} else {
 			panic("The default ewasm interpreter not supported yet.")
 		}
-	}
+	// }
 
 	if vmConfig.EVMInterpreter != "" {
 		evm.interpreters = append(evm.interpreters, &EVMC{evmModule, evm, evmc.CapabilityEVM1, false})
@@ -156,6 +158,10 @@ func NewEVM(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmCon
 		evm.interpreters = append(evm.interpreters, NewEVMInterpreter(evm, vmConfig))
 	}
 
+	// fmt.Println(vmConfig.EWASMInterpreter, vmConfig.EVMInterpreter)
+
+    // Exit with status 3.
+    // os.Exit(3)
 	evm.interpreter = evm.interpreters[0]
 
 	return evm
--- instructions.go
+++ instructions.go
@@ -19,6 +19,9 @@ package vm
 import (
 	"errors"
 	"math/big"
+	"fmt"
+	"os"
+	// "strings"
 
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/common/math"
@@ -400,6 +403,14 @@ func opSha3(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory
 	}
 	stack.push(interpreter.intPool.get().SetBytes(interpreter.hasherBuf[:]))
 
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte(fmt.Sprintf("SHA3: %x %x\n", data, interpreter.hasherBuf[:])))	
+    // fd.Close()
+
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte(fmt.Sprintf("SHA3: %x %x\n", offset, size)))	
+    // fd.Close()
+	
 	interpreter.intPool.put(offset, size)
 	return nil, nil
 }
@@ -422,6 +433,9 @@ func opOrigin(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memor
 
 func opCaller(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
 	stack.push(interpreter.intPool.get().SetBytes(contract.Caller().Bytes()))
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte(fmt.Sprintf("CALLER:\n")))	
+    // fd.Close()
 	return nil, nil
 }
 
@@ -628,6 +642,11 @@ func opMstore8(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memo
 
 func opSload(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
 	loc := stack.peek()
+
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("SLOAD: %064x\n", loc)))
+    fd.Close()
+
 	val := interpreter.evm.StateDB.GetState(contract.Address(), common.BigToHash(loc))
 	loc.SetBytes(val.Bytes())
 	return nil, nil
@@ -636,6 +655,11 @@ func opSload(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory
 func opSstore(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
 	loc := common.BigToHash(stack.pop())
 	val := stack.pop()
+	
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("SSTORE: %064x %064x\n", loc, val)))
+    fd.Close()
+
 	interpreter.evm.StateDB.SetState(contract.Address(), loc, common.BigToHash(val))
 
 	interpreter.intPool.put(val)
@@ -694,6 +718,11 @@ func opCreate(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memor
 		input        = memory.Get(offset.Int64(), size.Int64())
 		gas          = contract.Gas
 	)
+
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte(fmt.Sprintf("CREATE: %x %x\n", offset, size)))
+    // fd.Close()
+
 	if interpreter.evm.ChainConfig().IsEIP150(interpreter.evm.BlockNumber) {
 		gas -= gas / 64
 	}
@@ -729,6 +758,10 @@ func opCreate2(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memo
 		gas          = contract.Gas
 	)
 
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte(fmt.Sprintf("CREATE2: %x %x %x\n", offset, size, salt)))
+    // fd.Close()
+
 	// Apply EIP150
 	gas -= gas / 64
 	contract.UseGas(gas)
@@ -754,6 +787,11 @@ func opCall(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory
 	gas := interpreter.evm.callGasTemp
 	// Pop other call parameters.
 	addr, value, inOffset, inSize, retOffset, retSize := stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop()
+
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("CALL: \n")))
+    fd.Close()
+
 	toAddr := common.BigToAddress(addr)
 	value = math.U256(value)
 	// Get the arguments from the memory.
@@ -783,6 +821,11 @@ func opCallCode(pc *uint64, interpreter *EVMInterpreter, contract *Contract, mem
 	gas := interpreter.evm.callGasTemp
 	// Pop other call parameters.
 	addr, value, inOffset, inSize, retOffset, retSize := stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop()
+
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("CALLCODE: \n")))
+    fd.Close()
+
 	toAddr := common.BigToAddress(addr)
 	value = math.U256(value)
 	// Get arguments from the memory.
@@ -812,6 +855,11 @@ func opDelegateCall(pc *uint64, interpreter *EVMInterpreter, contract *Contract,
 	gas := interpreter.evm.callGasTemp
 	// Pop other call parameters.
 	addr, inOffset, inSize, retOffset, retSize := stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop()
+
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("CALLDELEGATE: \n")))
+    fd.Close()
+
 	toAddr := common.BigToAddress(addr)
 	// Get arguments from the memory.
 	args := memory.Get(inOffset.Int64(), inSize.Int64())
@@ -837,6 +885,11 @@ func opStaticCall(pc *uint64, interpreter *EVMInterpreter, contract *Contract, m
 	gas := interpreter.evm.callGasTemp
 	// Pop other call parameters.
 	addr, inOffset, inSize, retOffset, retSize := stack.pop(), stack.pop(), stack.pop(), stack.pop(), stack.pop()
+
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte(fmt.Sprintf("CALLSTATIC: \n")))
+    fd.Close()
+
 	toAddr := common.BigToAddress(addr)
 	// Get arguments from the memory.
 	args := memory.Get(inOffset.Int64(), inSize.Int64())
@@ -859,8 +912,12 @@ func opStaticCall(pc *uint64, interpreter *EVMInterpreter, contract *Contract, m
 func opReturn(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
 	offset, size := stack.pop(), stack.pop()
 	ret := memory.GetPtr(offset.Int64(), size.Int64())
-
 	interpreter.intPool.put(offset, size)
+	
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte("RETURN: \n"))
+    // fd.Close()
+
 	return ret, nil
 }
 
@@ -868,6 +925,10 @@ func opRevert(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memor
 	offset, size := stack.pop(), stack.pop()
 	ret := memory.GetPtr(offset.Int64(), size.Int64())
 
+	// fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	// fd.Write([]byte("REVERT: \n"))
+    // fd.Close()
+
 	interpreter.intPool.put(offset, size)
 	return ret, nil
 }
@@ -877,6 +938,10 @@ func opStop(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory
 }
 
 func opSuicide(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
+	fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+	fd.Write([]byte("SUICIDE: \n"))
+    fd.Close()
+
 	balance := interpreter.evm.StateDB.GetBalance(contract.Address())
 	interpreter.evm.StateDB.AddBalance(common.BigToAddress(stack.pop()), balance)
 
@@ -894,6 +959,15 @@ func makeLog(size int) executionFunc {
 		for i := 0; i < size; i++ {
 			topics[i] = common.BigToHash(stack.pop())
 		}
+		
+
+		fd, _ := os.OpenFile("/home/toor/evmTrans/testnet/ewasm-dev-env/geth/LOGS/tmp", os.O_RDWR|os.O_CREATE|os.O_APPEND,0666)
+		fd.Write([]byte(fmt.Sprintf("LOG: %x %x", mStart, mSize)))
+		for i := 0; i < size; i++ {
+			fd.Write([]byte(fmt.Sprintf(" %x", topics[i])))
+		}
+		fd.Write([]byte("\n"))
+    	fd.Close()
 
 		d := memory.Get(mStart.Int64(), mSize.Int64())
 		interpreter.evm.StateDB.AddLog(&types.Log{
--- api.go
+++ api.go
@@ -758,6 +758,7 @@ type CallArgs struct {
 func DoCall(ctx context.Context, b Backend, args CallArgs, blockNr rpc.BlockNumber, vmCfg vm.Config, timeout time.Duration, globalGasCap *big.Int) ([]byte, uint64, bool, error) {
 	defer func(start time.Time) { log.Debug("Executing EVM call finished", "runtime", time.Since(start)) }(time.Now())
 
+	// fmt.Errorf("====================== at DoCALL\n")
 	state, header, err := b.StateAndHeaderByNumber(ctx, blockNr)
 	if state == nil || err != nil {
 		return nil, 0, false, err
@@ -812,11 +813,13 @@ func DoCall(ctx context.Context, b Backend, args CallArgs, blockNr rpc.BlockNumb
 	// this makes sure resources are cleaned up.
 	defer cancel()
 
+	// fmt.Errorf("WOW Before GetEVM")
 	// Get a new instance of the EVM.
 	evm, vmError, err := b.GetEVM(ctx, msg, state, header)
 	if err != nil {
 		return nil, 0, false, err
 	}
+	// fmt.Errorf("WOW We Got EVM ")
 	// Wait for the context to be done and cancel the evm. Even if the
 	// EVM has finished, cancelling may be done (repeatedly)
 	go func() {
@@ -889,8 +892,11 @@ func DoEstimateGas(ctx context.Context, b Backend, args CallArgs, blockNr rpc.Bl
 	}
 	// Reject the transaction as invalid if it still fails at the highest allowance
 	if hi == cap {
+		// log.Warn("I am here ========================= hi=")
+		// fmt.Printf("|%d|\n", hi)
 		if !executable(hi) {
 			return 0, fmt.Errorf("gas required exceeds allowance (%d) or always failing transaction", cap)
+			// fmt.Errorf("gas required exceeds allowance (%d) or always failing transaction", cap)
 		}
 	}
 	return hexutil.Uint64(hi), nil
--- protocol_params.go
+++ protocol_params.go
@@ -69,7 +69,7 @@ const (
 	MemoryGas        uint64 = 3     // Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL.
 	TxDataNonZeroGas uint64 = 68    // Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions.
 
-	MaxCodeSize = 24576 // Maximum bytecode to permit for a contract
+	MaxCodeSize = 24576000*1024 // Maximum bytecode to permit for a contract
 
 	// Precompiled contract gas prices
 
